<?php
require_once __DIR__ . '/../../../../autoload.php';

/**
* Phing task to generate a Zend Framework style autoloader classmap file
*
* Usage example in a phing build.xml file:
*
* <target name="generate-classmap">
* <taskdef classname="ClassmapTask" name="classmap" />
*
* <!-- generate a classmap for library classes -->
* <classmap outputFile="${builddir}/library/autoload_classmap.php">
* <dirset dir="${builddir}/library">
* <include name="Zend" />
* <include name="MyLibrary" />
* </dirset>
* </classmap>
*
* <!-- generate a classmap for the MyApplication module -->
* <classmap outputFile="${builddir}/module/MyApplication/autoload_classmap.php">
* <dirset dir="${builddir}/module" includes="MyApplication" />
* </classmap>
* </target>
*
* This will generate a classmap file named 'library/autoload_classmap.php' in
* the ${builddir} directory (defined by a property), taking the "Zend" and
* "MyLibrary" directories under ${builddir}/library into account when searching
* for classes.
*
*/

class ClassmapTask extends Task
{
    /**
     * the source files
     *
     * @var array
     */
    protected $dirsets = array();

    /**
     * output filename
     *
     * @var string
     */
    protected $outputFile = "autoload_classmap.php";

    /**
     * output directory
     *
     * @var mixed
     */
    protected $outputDir = null;

    /**
     * if error occured, whether build should fail
     *
     * @var mixed
     */
    protected $failonerror = false;

    /**
     * nested creator, add a set of directories
     *
     * @return void
     */
    public function createDirSet()
    {
        $num = array_push($this->dirsets, new DirSet());
        return $this->dirsets[$num - 1];
    }

    /**
     * if error occured, whether build should fail
     *
     * @param bool $value
     * @return void
     */
    public function setFailonerror($value)
    {
        $this->failonerror = $value;
    }

    /**
     * output file
     *
     * @param string $outputFile
     * @return void
     */
    public function setOutputFile($outputFile)
    {
        $outputDir = realpath(dirname($outputFile));
        if (! $outputDir) {
            throw new BuildException("Output directory '$outputDir' does not exist");
        }

        $this->outputDir = $outputDir;
        $this->outputFile = basename($outputFile);
    }

    /**
     * init
     *
     * @return void
     */
    public function init()
    {
        $loader = new Zend\Loader\StandardAutoloader();
        $loader->register();
    }

    /**
     * main method
     *
     * @return void
     */
    public function main()
    {
        if (null === $this->outputDir) {
            $this->outputDir = getcwd();
        }

        foreach ($this->dirsets as $ds) { /* @var $ds DirSet */
            try {
                $dirs = $ds->getDirectoryScanner($this->project)->getIncludedDirectories();
                $fullPath = realpath($ds->getDir($this->project));
                $map = new stdClass();
                foreach ($dirs as $dir) {
                    $dir = $fullPath . "/" . $dir;
                    $this->log("Processing library dir: $dir");
                    $locator = new Zend\File\ClassFileLocator($dir);
                    foreach($locator as $file) {
                        $this->addFileToMap($file, $map);
                    }
                }

                $this->writeMapFile($map);

            } catch (BuildException $be) {
                // directory doesn't exist or is not readable
                if ($this->failonerror) {
                    throw $be;
                } else {
                    $this->log($be->getMessage(), $this->quiet ? Project::MSG_VERBOSE : Project::MSG_WARN);
                }
            }
        }
    }

    protected function addFileToMap(SplFileInfo $file, stdClass $map)
    {
        $filename = $this->getRelativePathFromMapFile($file);
        if (empty($file->classname)) return;
        $namespace = empty($file->namespace) ? '' : $file->namespace . '\\';
        $map->{$namespace . $file->classname} = "/" . ltrim($filename, "/");
    }

    protected function writeMapFile(stdClass $map)
    {
        $maxKeyLength = $this->findLongestKeyLength($map) + 2;

        $output = "<?php\n\n" .
                  "/**\n" .
                  " * Zend Framework autoloader classmap\n" .
                  " *\n" .
                  " * Auto-generated by Phing\\" . __CLASS__ . " at " . date(DATE_RFC2822) . "\n" .
                  " */\n\n" .
                  "return ";

        $classmap = var_export((array) $map, true);

        // Remove unnecessary double-backslashes
        $classmap = str_replace('\\\\', '\\', $classmap);

        // Exchange "array (" width "array("
        $classmap = str_replace('array (', 'array(', $classmap);

        $replaceFunc = function ($match) use ($maxKeyLength) {
            return sprintf(" %-{$maxKeyLength}s => __DIR__ .", $match[1]);
        };

        $output .= preg_replace_callback('/^\s+([^=]+)\s+=>/m', $replaceFunc, $classmap) . ';';

        $outputFile = $this->outputDir . '/' . $this->outputFile;
        if (! @file_put_contents($outputFile, $output)) {
            throw new BuildException("Unable to write classmap to $outputFile");
        }

        $this->log("Wrote autoloader classmap file to $outputFile");
    }

    /**
     * Get relative path to a class file from the classmap file path
     *
     * @param SplFileInfo $file
     * @return string
     */
    protected function getRelativePathFromMapFile(SplFileInfo $file)
    {
        if (strpos($file->getPath(), $this->outputDir) === 0) {
            $relativePath = substr($file->getPath(), strlen($this->outputDir) + 1) . '/';
        } else {
            $relative = array();
            $filePathParts = explode('/', $file->getPath());
            $outputDirParts = explode('/', $this->outputDir);

            foreach ($outputDirParts as $index => $part) {
                if (isset($filePathParts[$index]) && $filePathParts[$index] == $part) {
                    continue;
                }

                $relative[] = '..';
            }

            foreach ($filePathParts as $index => $part ) {
                if (isset($outputDirParts[$index]) && $outputDirParts[$index] == $part) {
                    continue;
                }

                $relative[] = $part;
            }

            $relativePath = implode('/', $relative) . '/';
        }

        return $relativePath . $file->getFilename();
    }

    /**
     * Get the length of the longest key in an object
     *
     * @param stdClass $map
     * @return int
     */
    protected function findLongestKeyLength(stdClass $map)
    {
        $max = 0;
        foreach(array_keys(get_object_vars($map)) as $key) {
            $max = max($max, strlen($key));
        }
        return $max;
    }
}
